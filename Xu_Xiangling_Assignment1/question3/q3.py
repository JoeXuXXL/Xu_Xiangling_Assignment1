from scipy import integrate
from scipy import ndimage
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image

#below is part a
print "part A: "
print " "
#define Bessel function
def besself(x, m):
#first define the integrand with given x and m
	def intgrand(theta):
#mutiplying by 1. to ensure returning float
		return np.cos(m * theta * 1. - x * np.sin(theta * 1.) * 1.)
#integrating with integrate.quad()
	I, err = integrate.quad(intgrand, 0, np.pi,)
	res = (1./np.pi) * I
	return res

#input values for calculating
X = input("enter the value for x for the Bessel function: ")
M = input("enter the order for the Bessel function(i.e. m): ")

print "the corresponding result of Bessel function"
print "of value", X, "and order", M, "is: ", besself(X,M)

raw_input("Press Enter to plot...")

#ploting Bessel function for 0<=x<10, and
#for m=0, 1, 2, 3, 4

#create and array of 1000 points for x, from 0 to 10
xa = np.arange(1000) / 100.

#as integrate.quad cannot handle array as input, here is alternative approach
#define function abesself(x,m), which is the array version of besself()
#that output an array with dim (somenumber,)
#therefore, can plot with array x and ym that generated by abesself(x,m)
def abesself(x,m):
#generate an empty list ymlist
	ymlist=[]	
#flatten() ensure any inputting array x be a (somenumber,) array
#so that the integrate.quad in besself() can handle it
	xflat = x.flatten()
#use for loop to add up elements into ymlist corresponding to input array x
#or more specifically, flattened x
	for i in xflat:
		ymlist.append(besself(i,m))
#converting ymlist into array ym for convienence in calculation
	ym = np.array(ymlist)
	return ym
#in addition abesself(x,m) is proven very useful in latter tasks

#customize figure, ploting functions with x and ygen(m)
plt.figure(figsize = (15,4))
plt.clf()
plt.plot(xa, abesself(xa,0), 'green', label='m=0')
plt.plot(xa, abesself(xa,1), 'blue', label='m=1')
plt.plot(xa, abesself(xa,2), 'pink', label='m=2')
plt.plot(xa, abesself(xa,3), 'red', label='m=3')
plt.plot(xa, abesself(xa,4), 'black', label='m=4')
plt.ylabel("y")
plt.xlabel("x")
plt.title("Bessel function for m=0, 1, 2, 3, 4, for interval 0<=x<10")
plt.legend()

print "plotting in process..."
plt.show()
print " "
print " "
#part a end

#below is for part b
print "Part b: "
raw_input("Press Enter to continue...")
print " "
print " "
I0 = input("enter the intensity at the center in W/m^2: ")
R = input("enter the distance from the aperture to the focal plane in mm: ")
a = input("enter the aperture radius in mm: ")
lam = input("enter the wavelength of light in nm: ")

#warning and options
print " "
print "The code works just fine when lambda is unconverted,"
print "though it is supposed to be converted from nm to m."
print " "
print "However, if doing so, the function integrate.quad()"
print "will give feedback 'integration warning: the integral"
print "is probably divergent, or slowly convergent' in terminal.'"
print " "
print "This may be caused by the input x is too big if converting lambda"
print "Regardless the warning, the code can run slowly."
print " "
print "Do you want to convert lambda anyway?"

#version choice(different lambda) by if
condition = input("enter 1 for converting lambda, and 0 for not:")

if condition == 1:
	lambdainvert = 1e9 * 1. /lam
elif condition == 0:
	lambdainvert = 1. /lam

print " "
print "plotting in process..."
print " "

#N is for resolution of the image, the choice of 600 is for part c
#where the shape of the picture is (272,275,3)
N = 275 

#generate array x, y for ploting, array x represents points 
#on x-axis with distance x from the center of telescope while y on y-axis 
x = np.linspace(-a,a,N)
y = np.linspace(-a,a,N)

#meshgird() helps for ploting imshow() graph
xv, yv=np.meshgrid(x,y)

#define the intensity function that will be plotted according to
#input x, y, with similar definition as above
def inten(x,y):
#Pythagorean theorem indicates the distance q from optical axis by below
	q = np.sqrt(x*x + y*y)
#x1 has same dim as q, say dim of q is (N,N)
	x1 = ((2*np.pi*a)/R) * lambdainvert * q
#by the flatten function incored in abesself(), J1 will have dim as (N**2,)
	J1 = abesself(x1,1)
#in order to do elementwise operation, need reshape J1 in dim (N,N)
	J1res = J1.reshape(N,N)
	return I0 * (2 * J1res / x1 )**2

#labeling plots and graphing plots
vals = inten(xv,yv)
plt.imshow(vals, cmap = 'Blues')
plt.title("The 2-D Image of Intensity on a Telescope's Focal Plane") 
plt.colorbar()
plt.xlabel("distance from the center of the focal plane in mm")
plt.ylabel("distance from the center of the focal plane in mm")

plt.show()

#below is for part c
print " "
print " "
print "Part c: "
print " "
raw_input("Press Enter to continue...")
print "it will take a while for processing the picture..."

#loading picture, converting in array, and fit it in the
#size of the given telescope in c
cosmos = Image.open("cosmos.jpg")
cosmosnp = np.array(cosmos)
cosmosim = cosmosnp[:N,:N,0]

#convolve and plot the image
inp = ndimage.filters.convolve(cosmosim,vals)
plt.imshow(cosmosim, cmap = 'Blues')
plt.title("The simulated figure of cosmos.jpg in telescope with given parameter")
plt.colorbar()

plt.show()
